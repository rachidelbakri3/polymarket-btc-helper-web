<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BTC Up/Down Helper â€” Live (Smart Vol)</title>
<style>
  :root{--bg:#0f172a;--card:#111827;--text:#e5e7eb;--muted:#9ca3af;--panel:#0b1020;--btn:#2563eb;}
  body{font-family:system-ui,Arial; background:var(--bg); color:var(--text); margin:0; padding:22px}
  h1{margin:0 0 14px;text-align:center;font-size:24px}
  .wrap{max-width:560px;margin:0 auto}
  .card{background:var(--card);border-radius:14px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .kpi{display:grid;grid-template-columns:1fr auto;gap:6px;background:var(--panel);padding:12px;border-radius:12px;margin-top:10px}
  .kpi b{font-size:16px}
  label{display:block;margin:14px 0 6px;color:var(--muted);font-size:13px}
  input,button{width:100%;padding:12px;border-radius:12px;border:1px solid #374151;background:var(--panel);color:var(--text)}
  button{border:0;background:var(--btn);font-weight:700;cursor:pointer;margin-top:10px}
  .foot{margin-top:10px;font-size:12px;color:var(--muted);text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <h1>BTC Up/Down Helper (Live â€¢ Smart Vol)</h1>
  <div class="card">

    <div class="row">
      <div class="kpi"><span>BTC (USDT)</span><b id="btcPrice">â€”</b></div>
      <div class="kpi"><span>Minutes Left (UTC)</span><b id="minsLeft">â€”</b></div>
    </div>

    <div class="kpi"><span>Price to Beat (1h open, UTC)</span><b id="ptb">â€”</b></div>
    <div class="kpi"><span>Volatility / min (EWMA)</span><b id="volMin">â€”</b></div>
    <div class="kpi"><span>Expected Move ($)</span><b id="expMove">â€”</b></div>

    <label>Current Up Price (from Polymarket) â€” Ø§Ø®ØªÙŠØ§Ø±ÙŠ</label>
    <input id="upPrice" type="number" step="0.01" placeholder="e.g. 0.62 (62Â¢)">
    <button id="recalcBtn">Calculate</button>

    <div class="row">
      <div class="kpi"><span>Up %</span><b id="upPct">â€”</b></div>
      <div class="kpi"><span>Down %</span><b id="downPct">â€”</b></div>
    </div>
    <div class="kpi"><span>Signal</span><b id="signal">â€”</b></div>

    <div class="foot" id="stamp">Initializingâ€¦</div>
    <div class="foot">Live: Binance WebSocket Â· Open/1m seed: Binance REST Â· Time: UTC</div>
  </div>
</div>

<script>
/* ===== Helpers ===== */
const fmt = (n, d=2)=>Number.isFinite(n)?n.toFixed(d):"â€”";
function hourWindowUTC(date=new Date()){
  const start = new Date(Date.UTC(date.getUTCFullYear(),date.getUTCMonth(),date.getUTCDate(),date.getUTCHours(),0,0));
  const end   = new Date(start.getTime()+3600_000);
  const minsLeft = Math.max(0, Math.floor((end - date)/60000));
  return {start, end, minsLeft};
}

/* ===== State ===== */
let lastPrice = null;
let ptb = null;            // price-to-beat (1h open)
let minsLeft = 0;
let volPerMin = null;      // % per minute
let expectedMove = null;   // $

// Ø«ÙˆØ§Ù†ÙŠ Ø¨Ø¯Ù„ ÙƒÙ„ ØµÙÙ‚Ø© (Ø£Ù†Ø¹Ù…)
let secTape = [];          // {tSec, p}
const MAX_TAPE_MINUTES = 30;
const MIN_WINDOW_MINS  = 5;

// EWMA Ø£ÙˆØ²Ø§Ù†
const ALPHA_BASE = 0.35, ALPHA_10M = 0.40, ALPHA_5M = 0.55;

/* ===== REST fetchers ===== */
async function fetchHourOpenUTC(startMs){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${startMs}&limit=1`;
  const r = await fetch(url, {cache:'no-store'});
  const j = await r.json();
  return (Array.isArray(j)&&j.length)?parseFloat(j[0][1]):null;
}
async function seed1mKlines(limit=60){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${limit}`;
  const r = await fetch(url,{cache:'no-store'}); const d = await r.json();
  if (!Array.isArray(d)) return;
  secTape = [];
  for (const k of d){
    const openMs = +k[0];
    const close  = +k[4];
    const tSec   = Math.floor((openMs + 30_000)/1000); // Ù…Ù†ØªØµÙ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©
    secTape.push({tSec, p: close});
  }
}

/* ===== Volatility: EWMA Ø¹Ù„Ù‰ Ø¹ÙˆØ§Ø¦Ø¯ Ø«ÙˆØ§Ù†ÙŠ â†’ Ù†Ø³Ø¨Ø© Ù„ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø© ===== */
function recalcVolSmart(){
  const cutoffSec = Math.floor(Date.now()/1000) - MAX_TAPE_MINUTES*60;
  secTape = secTape.filter(x => x.tSec >= cutoffSec);
  if (secTape.length < 6){ volPerMin = null; return; }

  const rets = [];
  for (let i=1;i<secTape.length;i++){
    const r = Math.log(secTape[i].p / secTape[i-1].p);
    if (Number.isFinite(r) && Math.abs(r) < 0.05) rets.push(r);
  }
  if (rets.length < 5){ volPerMin = null; return; }

  let a = ALPHA_BASE;
  if (minsLeft <= 5) a = ALPHA_5M;
  else if (minsLeft <= 10) a = ALPHA_10M;

  let mean = 0, varEW = 0;
  for (const r of rets){
    mean = (1-a)*mean + a*r;
    const diff = r - mean;
    varEW = (1-a)*varEW + a*diff*diff;
  }
  const sigmaPerSec = Math.sqrt(varEW);
  const sigmaPerMin = sigmaPerSec * Math.sqrt(60); // Ø¥Ù„Ù‰ Ø¯Ù‚ÙŠÙ‚Ø©
  volPerMin = sigmaPerMin * 100;                   // ÙƒÙ†Ø³Ø¨Ø© %
}

/* ===== Fair + Expected Move (Ù„ÙˆØ¬Ø³ØªÙŠ) ===== */
function computeFair(upMarket){
  const price = lastPrice ?? 0;
  const sigmaMinPct = volPerMin ?? 0; // %/min
  const t = Math.max(MIN_WINDOW_MINS, minsLeft || 1);

  const fracPct = sigmaMinPct * Math.sqrt(t); // % Ù…ØªÙˆÙ‚Ø¹Ø©
  const minPctFloor = 0.05;                   // Ø­Ø¯ Ø£Ø¯Ù†Ù‰ Ù…Ù†Ø·Ù‚ÙŠ
  const emPct = Math.max(fracPct, minPctFloor);

  expectedMove = price * (emPct / 100);       // Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±

  const gap = (ptb ?? price) - price;
  const k = 0.75;                              // Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù„ÙˆØ¬Ø³ØªÙŠÙƒ
  const x = gap / (k * expectedMove);
  const fairUp = 1 / (1 + Math.exp(-x));
  const fairDown = 1 - fairUp;

  const upPct = +(fairUp*100).toFixed(1);
  const downPct = +(fairDown*100).toFixed(1);

  const m = isNaN(upMarket) ? 0.5 : +upMarket;
  const signal = fairUp - m > 0.15 ? "ðŸŸ¢ Buy Up"
               : fairUp - m < -0.15 ? "ðŸ”´ Sell Up"
               : "âšª Neutral";
  return {upPct, downPct, signal};
}

/* ===== UI ===== */
function render(){
  document.getElementById('btcPrice').textContent = fmt(lastPrice,2);
  document.getElementById('ptb').textContent      = fmt(ptb,2);
  document.getElementById('minsLeft').textContent = minsLeft;
  document.getElementById('volMin').textContent   = Number.isFinite(volPerMin)? volPerMin.toFixed(3)+'%':'â€”';
  document.getElementById('expMove').textContent  = fmt(expectedMove,2);

  const upM = parseFloat(document.getElementById('upPrice').value);
  const {upPct, downPct, signal} = computeFair(upM);
  document.getElementById('upPct').textContent   = Number.isFinite(upPct)? upPct+'%':'â€”';
  document.getElementById('downPct').textContent = Number.isFinite(downPct)? downPct+'%':'â€”';
  document.getElementById('signal').textContent  = signal;

  const t = new Date().toISOString().replace('T',' ').slice(0,19);
  document.getElementById('stamp').textContent = `Last update: ${t} UTC`;
}

/* ===== Hourly maintenance ===== */
let currentHourStartMs = null;
async function ensurePTB(){
  const hw = hourWindowUTC();
  minsLeft = hw.minsLeft;
  if (currentHourStartMs !== hw.start.getTime()){
    currentHourStartMs = hw.start.getTime();
    ptb = await fetchHourOpenUTC(currentHourStartMs);
  }
}

/* ===== WebSocket live price (Ø«ÙˆØ§Ù†ÙŠ) ===== */
function startWS(){
  const ws = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@trade");
  ws.onmessage = (ev)=>{
    const { p, T } = JSON.parse(ev.data);
    const price = parseFloat(p);
    const tSec  = Math.floor((T || Date.now())/1000);
    lastPrice = price;

    if (secTape.length && secTape[secTape.length-1].tSec === tSec){
      secTape[secTape.length-1].p = price;
    } else {
      secTape.push({tSec, p: price});
    }

    recalcVolSmart();
    render();
  };
  ws.onclose = ()=> setTimeout(startWS, 1500);
}

/* ===== Bootstrap ===== */
document.getElementById('recalcBtn').addEventListener('click', render);

(async function boot(){
  await seed1mKlines(60);   // ØªØ¹Ø¨Ø¦Ø© Ø£ÙˆÙ„ÙŠØ©
  await ensurePTB();        // minsLeft + PTB
  startWS();
  render();
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª/Ø§Ù„Ù€ PTB ÙˆØ§Ù„Ù€ vol ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©
  setInterval(async ()=>{
    await ensurePTB();
    recalcVolSmart();
    render();
  }, 1000);
})();
</script>
</body>
</html>
