<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BTC Up/Down Hybrid</title>
<script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
<style>
  body{background:#0f172a;color:#fff;font-family:sans-serif;padding:20px}
  .wrap{max-width:500px;margin:auto}
  .kpi{display:flex;justify-content:space-between;padding:8px;background:#1e293b;margin:5px 0;border-radius:8px}
  .pos{color:#4ade80}
  .neg{color:#f87171}
  .gapPos{color:#22c55e;font-weight:bold}
  .gapNeg{color:#ef4444;font-weight:bold}
  .warn{color:#facc15;font-weight:bold}
</style>
</head>
<body>
<div class="wrap">
  <div class="kpi"><span>Price</span><b id="price">—</b></div>
  <div class="kpi"><span>Price to Beat</span><b id="ptb">—</b></div>
  <div class="kpi"><span>Time Left</span><b id="timeLeft">—</b></div>
  <div class="kpi"><span>Gap to Beat ($)</span><b id="gap">—</b></div>
  <div class="kpi"><span>Expected Move ($)</span><b id="expMove">—</b></div>
  <div class="kpi"><span>Strength (%)</span><b id="strength">—</b></div>
  <div class="kpi"><span>Up %</span><b id="upPct" class="pos">—</b></div>
  <div class="kpi"><span>Down %</span><b id="downPct" class="neg">—</b></div>
</div>

<script>
const { DateTime } = luxon;
let price = null, ptb = null, sigmaAnn = null;

function getHourWindowET(){
  const nowET = DateTime.now().setZone('America/New_York');
  const startET = nowET.startOf('hour');
  const endET = startET.plus({hours:1});
  return { startET, endET, nowET };
}

async function fetchPTB(){
  const { startET } = getHourWindowET();
  const startMsUTC = startET.toUTC().toMillis();
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${startMsUTC}&limit=1`;
  const r = await fetch(url);
  const j = await r.json();
  if(j && j.length) ptb = parseFloat(j[0][1]);
}

async function fetchCloses(mins){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${mins}`;
  const r = await fetch(url);
  const j = await r.json();
  return j.map(c=>+c[4]);
}

function stdDev(arr){
  const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
  return Math.sqrt(arr.reduce((a,b)=>a+(b-mean)**2,0)/arr.length);
}

function annualizedVol(closes){
  const rets = [];
  for(let i=1;i<closes.length;i++){
    rets.push(Math.log(closes[i]/closes[i-1]));
  }
  const sigmaPerMin = stdDev(rets);
  return sigmaPerMin * Math.sqrt(525600);
}

async function fetchHybridVol(){
  const short = await fetchCloses(5);
  const long = await fetchCloses(60);
  const sigS = annualizedVol(short);
  const sigL = annualizedVol(long);
  sigmaAnn = 0.7*sigS + 0.3*sigL;
}

function expectedMove(S, sigma, secsLeft){
  const T = secsLeft / 31536000;
  return S * sigma * Math.sqrt(T);
}

/* Normal CDF without Math.erf (Abramowitz–Stegun 7.1.26) */
function normCdf(z){
  const sign = z < 0 ? -1 : 1;
  const x = Math.abs(z) / Math.sqrt(2);
  const t = 1 / (1 + 0.3275911 * x);
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
  const y = 1 - (((((a5*t + a4)*t + a3)*t + a2)*t + a1)*t) * Math.exp(-x*x);
  const erf = sign * y;
  return 0.5 * (1 + erf);
}

const ws = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');
ws.onmessage = e => {
  const data = JSON.parse(e.data);
  price = parseFloat(data.p);
  render();
};

function render(){
  if(price!==null) document.getElementById('price').textContent = price.toFixed(2);
  if(ptb!==null) document.getElementById('ptb').textContent = ptb.toFixed(2);

  const { endET, nowET } = getHourWindowET();
  const secsLeft = Math.max(0, Math.floor(endET.diff(nowET,'seconds').seconds));
  const mins = String(Math.floor(secsLeft/60)).padStart(2,'0');
  const secs = String(secsLeft%60).padStart(2,'0');
  document.getElementById('timeLeft').textContent = `${mins}:${secs}`;

  if(price!==null && ptb!==null){
    const gap = price - ptb;
    const gapEl = document.getElementById('gap');
    gapEl.textContent = `${gap>=0?'+':''}${gap.toFixed(2)}`;
    gapEl.className = gap>=0?'gapPos':'gapNeg';

    if(sigmaAnn!==null){
      const em = expectedMove(price, sigmaAnn, secsLeft);
      const emEl = document.getElementById('expMove');
      emEl.textContent = em.toFixed(2);

      const gapAbs = Math.abs(gap);
      if(em > gapAbs * 1.1) emEl.className = 'pos';
      else if(em < gapAbs * 0.9) emEl.className = 'neg';
      else emEl.className = 'warn';

      // Strength %
      let strength = (gapAbs === 0) ? (em/price)*100 : (em/gapAbs)*100;
      const strEl = document.getElementById('strength');
      strEl.textContent = isFinite(strength) ? strength.toFixed(1)+'%' : '∞';
      if(strength > 110) strEl.className = 'pos';
      else if(strength < 90) strEl.className = 'neg';
      else strEl.className = 'warn';

      // Probabilities (guard when EM tiny)
      let pUp, pDown;
      if(em < 1e-6){
        pUp = 0.5; pDown = 0.5;
      } else {
        const z = (ptb - price) / em;
        pUp = 1 - normCdf(z);
        pUp = Math.max(0.01, Math.min(0.99, pUp));
        pDown = 1 - pUp;
      }
      document.getElementById('upPct').textContent = (pUp*100).toFixed(1)+'%';
      document.getElementById('downPct').textContent = (pDown*100).toFixed(1)+'%';
    }
  }
}

setInterval(fetchHybridVol, 5000);
setInterval(fetchPTB, 3600000);

fetchHybridVol();
fetchPTB();
</script>
</body>
</html>
