<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>BTC Up/Down — Black-Scholes Expected Move</title>
<style>
  :root{--bg:#0f172a;--card:#111827;--panel:#0b1020;--text:#e5e7eb;--muted:#9ca3af;--btn:#2563eb;}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Arial}
  .wrap{max-width:640px;margin:0 auto;padding:24px}
  h1{margin:0 0 16px;text-align:center}
  .card{background:var(--card);border-radius:14px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .kpi{display:grid;grid-template-columns:1fr auto;gap:6px;background:var(--panel);border-radius:12px;padding:12px;margin-top:10px}
  .kpi b{font-size:16px}
  label{display:block;margin:14px 0 6px;color:var(--muted);font-size:13px}
  input,button{width:100%;padding:12px;border-radius:12px;border:1px solid #374151;background:var(--panel);color:var(--text)}
  button{border:0;background:var(--btn);font-weight:700;cursor:pointer;margin-top:10px}
  .foot{margin-top:10px;text-align:center;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>BTC Up/Down (Black-Scholes)</h1>
  <div class="card">

    <div class="grid">
      <div class="kpi"><span>BTC (USDT)</span><b id="btc">—</b></div>
      <div class="kpi"><span>Minutes Left (UTC)</span><b id="mins">—</b></div>
    </div>

    <div class="kpi"><span>Price to Beat (1h open, UTC)</span><b id="ptb">—</b></div>

    <div class="grid">
      <div class="kpi"><span>Volatility $/min (last N mins)</span><b id="volDol">—</b></div>
      <div class="kpi"><span>σ annualized (Black-Scholes)</span><b id="sigmaAnn">—</b></div>
    </div>

    <div class="kpi"><span>Expected Move (Black-Scholes)</span><b id="em">—</b></div>

    <label>Current Up Price (Polymarket) — اختياري</label>
    <input id="upPrice" type="number" step="0.01" placeholder="e.g. 0.62 (62¢)">
    <button id="calc">Recalculate</button>

    <div class="grid">
      <div class="kpi"><span>Up %</span><b id="upPct">—</b></div>
      <div class="kpi"><span>Down %</span><b id="downPct">—</b></div>
    </div>
    <div class="kpi"><span>Signal</span><b id="signal">—</b></div>

    <div class="foot" id="stamp">Initializing…</div>
    <div class="foot">Live: Binance WebSocket · 1m/1h data: Binance REST · Time basis: UTC</div>
  </div>
</div>

<script>
/* ========= Config ========= */
const MINUTES_PER_YEAR = 525600;      // 365*24*60
const VOL_WINDOW_MINS  = 60;          // نافذة حساب $/min (يمكنك تغييرها)
const MIN_EM_PCT_FLOOR = 0.05;        // أدنى حركة متوقعة كنسبة % لمنع الصفر

/* ========= State ========= */
let lastPrice = null;                 // S
let ptb = null;                       // Price to Beat (1h open)
let minutesLeft = 0;                  // للساعة الجارية (UTC)
let sigmaDollarPerMin = null;         // انحراف معياري بدولار/دقيقة
let sigmaAnnual = null;               // Black-Scholes annualized σ (كنسبة)
let expectedMoveUSD = null;           // S * σ * sqrt(T)
let secTape = [];                     // {tSec, p} لتنعيم السعر بالثواني
let currentHourStart = null;

/* ========= Helpers ========= */
const fmt = (n,d=2)=>Number.isFinite(n)?n.toFixed(d):"—";
function hourWindowUTC(date=new Date()){
  const start = new Date(Date.UTC(date.getUTCFullYear(),date.getUTCMonth(),date.getUTCDate(),date.getUTCHours(),0,0));
  const end   = new Date(start.getTime()+3600_000);
  return {start, end, minutesLeft: Math.max(0, Math.floor((end - date)/60000))};
}
async function fetchHourOpenUTC(startMs){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${startMs}&limit=1`;
  const r = await fetch(url,{cache:'no-store'}); const j = await r.json();
  return (Array.isArray(j)&&j.length)?parseFloat(j[0][1]):null;
}
async function fetch1mCloses(limit=VOL_WINDOW_MINS+1){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${limit}`;
  const r = await fetch(url,{cache:'no-store'}); const data = await r.json();
  if (!Array.isArray(data) || data.length<2) return null;
  return data.map(k=>+k[4]); // close
}

/* ========= Volatility $/min =========
   stddev of consecutive 1m price changes (close-to-close) over last N minutes
===================================== */
function computeDollarVolPerMin(closes){
  const diffs = [];
  for(let i=1;i<closes.length;i++) diffs.push(closes[i]-closes[i-1]);
  if (diffs.length<2) return null;
  const mean = diffs.reduce((a,b)=>a+b,0)/diffs.length;
  const varp = diffs.reduce((s,x)=>s+(x-mean)*(x-mean),0)/diffs.length; // population
  return Math.sqrt(varp); // $/min
}

/* ========= Black-Scholes Expected Move =========
   σ_annual = (σ_$perMin / S) * sqrt(minutes/year)
   T(years) = minutesLeft / minutes/year
   EM($)    = S * σ_annual * sqrt(T)
   (يعني رياضيًا يساوي σ_$perMin * sqrt(minutesLeft) لكن نحسبها بصيغة BS)
=============================================== */
function computeBS_ExpectedMove(S, sigmaDolPerMin, minsLeft){
  if(!(S>0) || !(sigmaDolPerMin>0) || !(minsLeft>=0)) return {sigmaAnn:null, em:null};
  const sigmaAnn = (sigmaDolPerMin / S) * Math.sqrt(MINUTES_PER_YEAR); // نسبة سنوية
  const T = minsLeft / MINUTES_PER_YEAR;                                // سنوات
  const em = S * sigmaAnn * Math.sqrt(T);                               // $
  return {sigmaAnn, em};
}

/* ========= Probabilities (logistic) ========= */
function computeProbsAndSignal(upMarket){
  const S = lastPrice ?? 0;
  const gap = (ptb ?? S) - S;
  // أرضية للحركة المتوقعة كنسبة من السعر
  const emPct = Math.max(MIN_EM_PCT_FLOOR, (expectedMoveUSD ?? 0)/Math.max(1,S)*100);
  const scale = Math.max(1e-9, (emPct/100)*S); // مقياس بالدولار
  const k = 0.85; // حساسية
  const x = gap / (k * scale);
  const up = 1/(1+Math.exp(-x));
  const down = 1-up;
  const m = isNaN(upMarket)?0.5:+upMarket;
  const sig = up - m > 0.15 ? "🟢 Buy Up" : (up - m < -0.15 ? "🔴 Sell Up" : "⚪ Neutral");
  return {upPct:+(up*100).toFixed(1), downPct:+(down*100).toFixed(1), sig};
}

/* ========= Rendering ========= */
function render(){
  document.getElementById('btc').textContent      = fmt(lastPrice,2);
  document.getElementById('mins').textContent     = minutesLeft;
  document.getElementById('ptb').textContent      = fmt(ptb,2);
  document.getElementById('volDol').textContent   = sigmaDollarPerMin!=null ? fmt(sigmaDollarPerMin,2) : '—';
  document.getElementById('sigmaAnn').textContent = sigmaAnnual!=null ? (sigmaAnnual*100).toFixed(2)+'%' : '—';
  document.getElementById('em').textContent       = expectedMoveUSD!=null ? fmt(expectedMoveUSD,2) : '—';

  const upM = parseFloat(document.getElementById('upPrice').value);
  const {upPct,downPct,sig} = computeProbsAndSignal(upM);
  document.getElementById('upPct').textContent = Number.isFinite(upPct)? upPct+'%':'—';
  document.getElementById('downPct').textContent = Number.isFinite(downPct)? downPct+'%':'—';
  document.getElementById('signal').textContent = sig;

  document.getElementById('stamp').textContent =
    'Last update: ' + new Date().toISOString().replace('T',' ').slice(0,19) + ' UTC';
}

/* ========= Hour maintenance (PTB + minutesLeft) ========= */
async function refreshHourStuff(){
  const {start, minutesLeft:ml} = hourWindowUTC();
  minutesLeft = ml;
  if (currentHourStart !== start.getTime()){
    currentHourStart = start.getTime();
    ptb = await fetchHourOpenUTC(currentHourStart);
  }
}

/* ========= Refresh 1m volatility each minute ========= */
let lastVolMinute = null;
async function refreshVolIfNewMinute(){
  const nowMin = Math.floor(Date.now()/60000);
  if (nowMin !== lastVolMinute){
    lastVolMinute = nowMin;
    const closes = await fetch1mCloses(VOL_WINDOW_MINS+1);
    const volDol = closes ? computeDollarVolPerMin(closes) : null;
    sigmaDollarPerMin = volDol;

    // بعد تحديث $/min، احسب σ السنوية و EM بمعادلة Black-Scholes
    if (lastPrice!=null && sigmaDollarPerMin!=null){
      const {sigmaAnn, em} = computeBS_ExpectedMove(lastPrice, sigmaDollarPerMin, minutesLeft);
      sigmaAnnual = sigmaAnn;
      expectedMoveUSD = em;
    }
  }
}

/* ========= WebSocket live price (per second tape) ========= */
function startWS(){
  const ws = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@trade");
  ws.onmessage = (ev)=>{
    const {p,T} = JSON.parse(ev.data);
    const price = parseFloat(p);
    const tSec  = Math.floor((T||Date.now())/1000);
    lastPrice = price;
    if (secTape.length && secTape[secTape.length-1].tSec===tSec) secTape[secTape.length-1].p=price;
    else secTape.push({tSec,p:price});
    // حدّث EM فورًا باستخدام σ_$/min الأحدث
    if (sigmaDollarPerMin!=null){
      const res = computeBS_ExpectedMove(lastPrice, sigmaDollarPerMin, minutesLeft);
      sigmaAnnual = res.sigmaAnn; expectedMoveUSD = res.em;
    }
    render();
  };
  ws.onclose = ()=> setTimeout(startWS, 1500);
}

/* ========= Boot ========= */
document.getElementById('calc').addEventListener('click', render);

(async function boot(){
  await refreshHourStuff();
  await refreshVolIfNewMinute();  // حساب أولي للـ $/min والـ EM
  startWS();
  render();

  // كل ثانية: حدّث الوقت المتبقي، وعند دخول دقيقة جديدة يعاد حساب $/min تلقائيًا
  setInterval(async ()=>{
    await refreshHourStuff();
    await refreshVolIfNewMinute();
    render();
  }, 1000);
})();
</script>
</body>
</html>
