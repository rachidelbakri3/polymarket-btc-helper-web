<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BTC Up/Down Helper — Live (Smart Vol)</title>
<style>
  :root{--bg:#0f172a;--card:#111827;--text:#e5e7eb;--muted:#9ca3af;--panel:#0b1020;--btn:#2563eb;}
  body{font-family:system-ui,Arial; background:var(--bg); color:var(--text); margin:0; padding:22px}
  h1{margin:0 0 14px;text-align:center;font-size:24px}
  .wrap{max-width:560px;margin:0 auto}
  .card{background:var(--card);border-radius:14px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .kpi{display:grid;grid-template-columns:1fr auto;gap:6px;background:var(--panel);padding:12px;border-radius:12px;margin-top:10px}
  .kpi b{font-size:16px}
  label{display:block;margin:14px 0 6px;color:var(--muted);font-size:13px}
  input,button{width:100%;padding:12px;border-radius:12px;border:1px solid #374151;background:var(--panel);color:var(--text)}
  button{border:0;background:var(--btn);font-weight:700;cursor:pointer;margin-top:10px}
  .foot{margin-top:10px;font-size:12px;color:var(--muted);text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <h1>BTC Up/Down Helper (Live • Smart Vol)</h1>
  <div class="card">

    <div class="row">
      <div class="kpi"><span>BTC (USDT)</span><b id="btcPrice">—</b></div>
      <div class="kpi"><span>Minutes Left (UTC)</span><b id="minsLeft">—</b></div>
    </div>

    <div class="kpi"><span>Price to Beat (1h open, UTC)</span><b id="ptb">—</b></div>
    <div class="kpi"><span>Volatility / min (EWMA)</span><b id="volMin">—</b></div>
    <div class="kpi"><span>Expected Move</span><b id="expMove">—</b></div>

    <label>Current Up Price (from Polymarket) — اختياري</label>
    <input id="upPrice" type="number" step="0.01" placeholder="e.g. 0.62 (62¢)">
    <button id="recalcBtn">Calculate</button>

    <div class="row">
      <div class="kpi"><span>Up %</span><b id="upPct">—</b></div>
      <div class="kpi"><span>Down %</span><b id="downPct">—</b></div>
    </div>
    <div class="kpi"><span>Signal</span><b id="signal">—</b></div>

    <div class="foot" id="stamp">Initializing…</div>
    <div class="foot">Live price: Binance WebSocket. Open/1m seed: Binance REST. Time basis: UTC.</div>
  </div>
</div>

<script>
/* ===== Helpers ===== */
const fmt = (n, d=2)=>Number.isFinite(n)?n.toFixed(d):"—";
function hourWindowUTC(date=new Date()){
  const start = new Date(Date.UTC(date.getUTCFullYear(),date.getUTCMonth(),date.getUTCDate(),date.getUTCHours(),0,0));
  const end   = new Date(start.getTime()+3600_000);
  const minsLeft = Math.max(0, Math.floor((end - date)/60000));
  return {start, end, minsLeft};
}

/* ===== State ===== */
let lastPrice = null;
let ptb = null; // price-to-beat (1h open)
let minsLeft = 0;
let volPerMin = null;
let expectedMove = null;

// شريط الأسعار من الستريم (نستخدمه لـ EWMA returns)
let priceTape = []; // عناصر: {t, p}
const MAX_TAPE_MINUTES = 30; // نحتفظ بآخر 30 دقيقة كحد أقصى
const MIN_WINDOW_MINS  = 5;  // أقل زمن نعتبره في الجذر

/* ===== إعدادات EWMA للتذبذب الذكي ===== */
const EWMA_ALPHA_BASE = 0.35; // أساس
const EWMA_ALPHA_10M  = 0.40; // لو الوقت المتبقي ≤ 10m
const EWMA_ALPHA_5M   = 0.50; // لو الوقت المتبقي ≤ 5m

/* ===== Fair price heuristic ===== */
function computeFair(upMarket){
  const curr = lastPrice ?? 0;
  const vm = volPerMin ?? 0;
  const ml = Math.max(1, minsLeft || 1);

  // حركة متوقعة كنسبة = sigma_per_min * sqrt(minutesLeftAdjusted)
  const fracMove = vm * Math.sqrt(Math.max(MIN_WINDOW_MINS, ml));
  expectedMove = curr * fracMove; // بالدولار

  const gapImpact = expectedMove ? (ptb - curr)/expectedMove : 0;
  let fairUp = Math.max(0, Math.min(1, 0.5 + gapImpact/100)); // تحويل بسيط للاحتمال
  const fairDown = 1 - fairUp;

  const upPct = +(fairUp*100).toFixed(1);
  const downPct = +(fairDown*100).toFixed(1);

  const m = isNaN(upMarket) ? 0.5 : +upMarket;
  const diff = fairUp - m;
  let signal = "⚪ Neutral";
  if (diff > 0.15) signal = "🟢 Buy Up";
  else if (diff < -0.15) signal = "🔴 Sell Up";

  return { upPct, downPct, signal };
}

/* ===== REST fetchers ===== */
async function fetchHourOpenUTC(startMs){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${startMs}&limit=1`;
  const r = await fetch(url, {cache:'no-store'});
  const j = await r.json();
  return (Array.isArray(j)&&j.length)?parseFloat(j[0][1]):null;
}
async function seed1mKlines(limit=20){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${limit}`;
  const r = await fetch(url, {cache:'no-store'});
  const d = await r.json();
  if (!Array.isArray(d)) return;
  const now = Date.now();
  priceTape = d.map(k => ({ t:+k[0]+30_000, p:+k[4] })) // منتصف الدقيقة
               .filter(x => now - x.t <= MAX_TAPE_MINUTES*60*1000);
}

/* ===== Volatility: EWMA returns with time-left aware alpha ===== */
function recalcVolSmart(){
  const cutoff = Date.now() - MAX_TAPE_MINUTES*60*1000;
  priceTape = priceTape.filter(x => x.t >= cutoff);
  if (priceTape.length < 3){ volPerMin = null; return; }

  const rets = [];
  for (let i=1;i<priceTape.length;i++){
    const r = Math.log(priceTape[i].p / priceTape[i-1].p);
    if (Number.isFinite(r) && Math.abs(r) < 0.05) rets.push(r);
  }
  if (rets.length < 3){ volPerMin = null; return; }

  // اختر alpha حسب الوقت المتبقي
  let alpha = EWMA_ALPHA_BASE;
  if (minsLeft <= 5) alpha = EWMA_ALPHA_5M;
  else if (minsLeft <= 10) alpha = EWMA_ALPHA_10M;

  let mean = 0, varEW = 0;
  for (const r of rets){
    mean = (1-alpha)*mean + alpha*r;
    const diff = r - mean;
    varEW = (1-alpha)*varEW + alpha*(diff*diff);
  }
  const sigmaPerStep = Math.sqrt(varEW);   // لكل تحديث (≈ ثانية)
  const sigmaPerMin  = sigmaPerStep * Math.sqrt(60); // إلى دقيقة
  volPerMin = sigmaPerMin;
}

/* ===== UI ===== */
function render(){
  document.getElementById('btcPrice').textContent = fmt(lastPrice,2);
  document.getElementById('ptb').textContent      = fmt(ptb,2);
  document.getElementById('minsLeft').textContent = minsLeft;
  document.getElementById('volMin').textContent   = fmt(volPerMin,4);
  document.getElementById('expMove').textContent  = fmt(expectedMove,2);

  const upM = parseFloat(document.getElementById('upPrice').value);
  const {upPct, downPct, signal} = computeFair(upM);
  document.getElementById('upPct').textContent   = Number.isFinite(upPct)? upPct+'%':'—';
  document.getElementById('downPct').textContent = Number.isFinite(downPct)? downPct+'%':'—';
  document.getElementById('signal').textContent  = signal;

  const t = new Date().toISOString().replace('T',' ').slice(0,19);
  document.getElementById('stamp').textContent = `Last update: ${t} UTC`;
}

/* ===== Hourly maintenance ===== */
let currentHourStartMs = null;
async function ensurePTB(){
  const hw = hourWindowUTC();
  minsLeft = hw.minsLeft;
  if (currentHourStartMs !== hw.start.getTime()){
    currentHourStartMs = hw.start.getTime();
    ptb = await fetchHourOpenUTC(currentHourStartMs);
  }
}

/* ===== WebSocket live price ===== */
function startWS(){
  const ws = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@trade");
  ws.onmessage = (ev)=>{
    const msg = JSON.parse(ev.data);
    const p = parseFloat(msg.p);
    const t = msg.T || Date.now();
    lastPrice = p;
    priceTape.push({t, p});
    recalcVolSmart(); // يعتمد على minsLeft داخليًا
    render();
  };
  ws.onclose = ()=>{ setTimeout(startWS, 1500); };
}

/* ===== Bootstrap ===== */
document.getElementById('recalcBtn').addEventListener('click', render);

(async function boot(){
  await seed1mKlines(30); // تهيئة الشريط
  await ensurePTB();      // احسب minsLeft + اجلب PTB
  startWS();
  render();
  // حدّث الوقت المتبقي + PTB + vol كل ثانية
  setInterval(async ()=>{
    await ensurePTB();
    recalcVolSmart();
    render();
  }, 1000);
})();
</script>
</body>
</html>
