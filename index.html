<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BTC Up/Down Helper â€” Live (Smart Vol)</title>
<style>
  :root{--bg:#0f172a;--card:#111827;--text:#e5e7eb;--muted:#9ca3af;--panel:#0b1020;--btn:#2563eb;}
  body{font-family:system-ui,Arial; background:var(--bg); color:var(--text); margin:0; padding:22px}
  h1{margin:0 0 14px;text-align:center;font-size:24px}
  .wrap{max-width:560px;margin:0 auto}
  .card{background:var(--card);border-radius:14px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .kpi{display:grid;grid-template-columns:1fr auto;gap:6px;background:var(--panel);padding:12px;border-radius:12px;margin-top:10px}
  .kpi b{font-size:16px}
  label{display:block;margin:14px 0 6px;color:var(--muted);font-size:13px}
  input,button{width:100%;padding:12px;border-radius:12px;border:1px solid #374151;background:var(--panel);color:var(--text)}
  button{border:0;background:var(--btn);font-weight:700;cursor:pointer;margin-top:10px}
  .foot{margin-top:10px;font-size:12px;color:var(--muted);text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <h1>BTC Up/Down Helper (Live â€¢ Smart Vol)</h1>
  <div class="card">

    <div class="row">
      <div class="kpi"><span>BTC (USDT)</span><b id="btcPrice">â€”</b></div>
      <div class="kpi"><span>Minutes Left (UTC)</span><b id="minsLeft">â€”</b></div>
    </div>

    <div class="kpi"><span>Price to Beat (1h open, UTC)</span><b id="ptb">â€”</b></div>
    <div class="kpi"><span>Volatility / min (EWMA)</span><b id="volMin">â€”</b></div>
    <div class="kpi"><span>Expected Move</span><b id="expMove">â€”</b></div>

    <label>Current Up Price (from Polymarket) â€” Ø§Ø®ØªÙŠØ§Ø±ÙŠ</label>
    <input id="upPrice" type="number" step="0.01" placeholder="e.g. 0.62 (62Â¢)">
    <button id="recalcBtn">Calculate</button>

    <div class="row">
      <div class="kpi"><span>Up %</span><b id="upPct">â€”</b></div>
      <div class="kpi"><span>Down %</span><b id="downPct">â€”</b></div>
    </div>
    <div class="kpi"><span>Signal</span><b id="signal">â€”</b></div>

    <div class="foot" id="stamp">Initializingâ€¦</div>
    <div class="foot">Live price: Binance WebSocket. Open/1m seed: Binance REST. Time basis: UTC.</div>
  </div>
</div>

<script>
/* ===== Helpers ===== */
const fmt = (n, d=2)=>Number.isFinite(n)?n.toFixed(d):"â€”";
function hourWindowUTC(date=new Date()){
  const start = new Date(Date.UTC(date.getUTCFullYear(),date.getUTCMonth(),date.getUTCDate(),date.getUTCHours(),0,0));
  const end   = new Date(start.getTime()+3600_000);
  const minsLeft = Math.max(0, Math.floor((end - date)/60000));
  return {start, end, minsLeft};
}

/* ===== State ===== */
let lastPrice = null;
let ptb = null; // price-to-beat (1h open)
let minsLeft = 0;
let volPerMin = null;
let expectedMove = null;

// Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† Ø§Ù„Ø³ØªØ±ÙŠÙ… (Ù†Ø³ØªØ®Ø¯Ù…Ù‡ Ù„Ù€ EWMA returns)
let priceTape = []; // Ø¹Ù†Ø§ØµØ±: {t, p}
const MAX_TAPE_MINUTES = 30; // Ù†Ø­ØªÙØ¸ Ø¨Ø¢Ø®Ø± 30 Ø¯Ù‚ÙŠÙ‚Ø© ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
const MIN_WINDOW_MINS  = 5;  // Ø£Ù‚Ù„ Ø²Ù…Ù† Ù†Ø¹ØªØ¨Ø±Ù‡ ÙÙŠ Ø§Ù„Ø¬Ø°Ø±

/* ===== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª EWMA Ù„Ù„ØªØ°Ø¨Ø°Ø¨ Ø§Ù„Ø°ÙƒÙŠ ===== */
const EWMA_ALPHA_BASE = 0.35; // Ø£Ø³Ø§Ø³
const EWMA_ALPHA_10M  = 0.40; // Ù„Ùˆ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ â‰¤ 10m
const EWMA_ALPHA_5M   = 0.50; // Ù„Ùˆ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ â‰¤ 5m

/* ===== Fair price heuristic ===== */
function computeFair(upMarket){
  const curr = lastPrice ?? 0;
  const vm = volPerMin ?? 0;
  const ml = Math.max(1, minsLeft || 1);

  // Ø­Ø±ÙƒØ© Ù…ØªÙˆÙ‚Ø¹Ø© ÙƒÙ†Ø³Ø¨Ø© = sigma_per_min * sqrt(minutesLeftAdjusted)
  const fracMove = vm * Math.sqrt(Math.max(MIN_WINDOW_MINS, ml));
  expectedMove = curr * fracMove; // Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±

  const gapImpact = expectedMove ? (ptb - curr)/expectedMove : 0;
  let fairUp = Math.max(0, Math.min(1, 0.5 + gapImpact/100)); // ØªØ­ÙˆÙŠÙ„ Ø¨Ø³ÙŠØ· Ù„Ù„Ø§Ø­ØªÙ…Ø§Ù„
  const fairDown = 1 - fairUp;

  const upPct = +(fairUp*100).toFixed(1);
  const downPct = +(fairDown*100).toFixed(1);

  const m = isNaN(upMarket) ? 0.5 : +upMarket;
  const diff = fairUp - m;
  let signal = "âšª Neutral";
  if (diff > 0.15) signal = "ðŸŸ¢ Buy Up";
  else if (diff < -0.15) signal = "ðŸ”´ Sell Up";

  return { upPct, downPct, signal };
}

/* ===== REST fetchers ===== */
async function fetchHourOpenUTC(startMs){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${startMs}&limit=1`;
  const r = await fetch(url, {cache:'no-store'});
  const j = await r.json();
  return (Array.isArray(j)&&j.length)?parseFloat(j[0][1]):null;
}
async function seed1mKlines(limit=20){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${limit}`;
  const r = await fetch(url, {cache:'no-store'});
  const d = await r.json();
  if (!Array.isArray(d)) return;
  const now = Date.now();
  priceTape = d.map(k => ({ t:+k[0]+30_000, p:+k[4] })) // Ù…Ù†ØªØµÙ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©
               .filter(x => now - x.t <= MAX_TAPE_MINUTES*60*1000);
}

/* ===== Volatility: EWMA returns with time-left aware alpha ===== */
function recalcVolSmart(){
  const cutoff = Date.now() - MAX_TAPE_MINUTES*60*1000;
  priceTape = priceTape.filter(x => x.t >= cutoff);
  if (priceTape.length < 3){ volPerMin = null; return; }

  const rets = [];
  for (let i=1;i<priceTape.length;i++){
    const r = Math.log(priceTape[i].p / priceTape[i-1].p);
    if (Number.isFinite(r) && Math.abs(r) < 0.05) rets.push(r);
  }
  if (rets.length < 3){ volPerMin = null; return; }

  // Ø§Ø®ØªØ± alpha Ø­Ø³Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
  let alpha = EWMA_ALPHA_BASE;
  if (minsLeft <= 5) alpha = EWMA_ALPHA_5M;
  else if (minsLeft <= 10) alpha = EWMA_ALPHA_10M;

  let mean = 0, varEW = 0;
  for (const r of rets){
    mean = (1-alpha)*mean + alpha*r;
    const diff = r - mean;
    varEW = (1-alpha)*varEW + alpha*(diff*diff);
  }
  const sigmaPerStep = Math.sqrt(varEW);   // Ù„ÙƒÙ„ ØªØ­Ø¯ÙŠØ« (â‰ˆ Ø«Ø§Ù†ÙŠØ©)
  const sigmaPerMin  = sigmaPerStep * Math.sqrt(60); // Ø¥Ù„Ù‰ Ø¯Ù‚ÙŠÙ‚Ø©
  volPerMin = sigmaPerMin;
}

/* ===== UI ===== */
function render(){
  document.getElementById('btcPrice').textContent = fmt(lastPrice,2);
  document.getElementById('ptb').textContent      = fmt(ptb,2);
  document.getElementById('minsLeft').textContent = minsLeft;
  document.getElementById('volMin').textContent   = fmt(volPerMin,4);
  document.getElementById('expMove').textContent  = fmt(expectedMove,2);

  const upM = parseFloat(document.getElementById('upPrice').value);
  const {upPct, downPct, signal} = computeFair(upM);
  document.getElementById('upPct').textContent   = Number.isFinite(upPct)? upPct+'%':'â€”';
  document.getElementById('downPct').textContent = Number.isFinite(downPct)? downPct+'%':'â€”';
  document.getElementById('signal').textContent  = signal;

  const t = new Date().toISOString().replace('T',' ').slice(0,19);
  document.getElementById('stamp').textContent = `Last update: ${t} UTC`;
}

/* ===== Hourly maintenance ===== */
let currentHourStartMs = null;
async function ensurePTB(){
  const hw = hourWindowUTC();
  minsLeft = hw.minsLeft;
  if (currentHourStartMs !== hw.start.getTime()){
    currentHourStartMs = hw.start.getTime();
    ptb = await fetchHourOpenUTC(currentHourStartMs);
  }
}

/* ===== WebSocket live price ===== */
function startWS(){
  const ws = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@trade");
  ws.onmessage = (ev)=>{
    const msg = JSON.parse(ev.data);
    const p = parseFloat(msg.p);
    const t = msg.T || Date.now();
    lastPrice = p;
    priceTape.push({t, p});
    recalcVolSmart(); // ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ minsLeft Ø¯Ø§Ø®Ù„ÙŠÙ‹Ø§
    render();
  };
  ws.onclose = ()=>{ setTimeout(startWS, 1500); };
}

/* ===== Bootstrap ===== */
document.getElementById('recalcBtn').addEventListener('click', render);

(async function boot(){
  await seed1mKlines(30); // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø´Ø±ÙŠØ·
  await ensurePTB();      // Ø§Ø­Ø³Ø¨ minsLeft + Ø§Ø¬Ù„Ø¨ PTB
  startWS();
  render();
  // Ø­Ø¯Ù‘Ø« Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ + PTB + vol ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©
  setInterval(async ()=>{
    await ensurePTB();
    recalcVolSmart();
    render();
  }, 1000);
})();
</script>
</body>
</html>
