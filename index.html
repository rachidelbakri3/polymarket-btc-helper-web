<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BTC Up/Down — Hybrid (ET Hour)</title>
<style>
  :root{
    --bg:#0f1115; --card:#171a21; --muted:#9aa4b2; --text:#e6ebf1;
    --good:#3ad29f; --bad:#ff5d5d; --accent:#7aa2ff;
    --radius:18px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, "Noto Kufi Arabic", Arial;
    background:var(--bg); color:var(--text);
  }
  .wrap{max-width:780px; margin:28px auto; padding:0 16px}
  h1{font-weight:800; letter-spacing:.2px; margin:0 0 8px 0; font-size:28px}
  .sub{color:var(--muted); font-size:14px; margin-bottom:18px}
  .grid{display:grid; grid-template-columns:1fr; gap:12px}
  @media(min-width:680px){ .grid{grid-template-columns:1fr 1fr} }
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.0)) , var(--card);
    border:1px solid rgba(255,255,255,0.06); border-radius:var(--radius);
    padding:14px 16px; display:flex; justify-content:space-between; align-items:center;
    box-shadow:0 10px 30px rgba(0,0,0,.35);
  }
  .label{color:var(--muted); font-size:12px; text-transform:uppercase; letter-spacing:.7px}
  .value{font-size:20px; font-weight:800}
  .row-2{grid-column:1 / -1}
  .good{color:var(--good)} .bad{color:var(--bad)} .accent{color:var(--accent)}
  .tiny{font-size:12px; color:var(--muted)}
  .footer{margin-top:18px; color:var(--muted); font-size:12px}
  .pill{
    display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px;
    background:rgba(122,162,255,.08); border:1px solid rgba(122,162,255,.25); font-size:12px;
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>BTC Up/Down — Hybrid</h1>
    <div class="sub">
      Live from Binance · <span id="windowLabel">Hour window (ET)</span>
      · <span class="pill"><span>Symbol:</span><span id="sym">BTCUSDT</span></span>
    </div>

    <div class="grid">
      <div class="card row-2">
        <div>
          <div class="label">PRICE</div>
          <div class="value" id="price">—</div>
          <div class="tiny" id="ts">—</div>
        </div>
      </div>

      <div class="card">
        <div class="label">PRICE TO BEAT</div>
        <div class="value" id="k">—</div>
      </div>

      <div class="card">
        <div class="label">TIME LEFT</div>
        <div class="value" id="timeleft">—</div>
      </div>

      <div class="card">
        <div class="label">GAP TO BEAT ($)</div>
        <div class="value" id="gap">—</div>
      </div>

      <div class="card">
        <div class="label">EXPECTED MOVE ($)</div>
        <div class="value accent" id="em">—</div>
      </div>

      <div class="card">
        <div class="label">EM LEFT ($)</div>
        <div class="value" id="emleft">—</div>
      </div>

      <div class="card">
        <div class="label">STRENGTH (%)</div>
        <div class="value" id="strength">—</div>
      </div>

      <div class="card">
        <div class="label">UP %</div>
        <div class="value good" id="up">—</div>
      </div>

      <div class="card">
        <div class="label">DOWN %</div>
        <div class="value bad" id="down">—</div>
      </div>
    </div>

    <div class="footer" id="footer">Last update: — · WebSocket: Binance · TZ: America/New_York (ET)</div>
  </div>

<script>
/* ============== SETTINGS ============== */
const SYMBOL = 'btcusdt';          // stream symbol
const REST_SYMBOL = 'BTCUSDT';     // REST symbol (case-sensitive)
const HOURS_FOR_RVOL = 500;        // how many hourly candles to estimate realized vol
const RISK_FREE = 0.00;            // risk-free rate for Black–Scholes (hourly, ~0)

/* ============== UTILITIES ============== */
const fmt = (n, d=2) => {
  if (!isFinite(n)) return '—';
  return Number(n).toLocaleString('en-US', {maximumFractionDigits:d, minimumFractionDigits:d});
};
const signFmt = (x, d=2) => (x>=0?'+':'') + fmt(x, d);

function normalCDF(x){ // N(x)
  // Abramowitz-Stegun approximation
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
  const sign = x<0?-1:1; x=Math.abs(x)/Math.SQRT2;
  const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
  return 0.5*(1+sign*y);
}

function toET(dateUtc){
  // returns Date object adjusted to America/New_York wall clock
  const et = new Intl.DateTimeFormat('en-US',{timeZone:'America/New_York', hour12:false,
    year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit'});
  const parts = et.formatToParts(dateUtc).reduce((a,p)=>{a[p.type]=p.value; return a;},{});
  return new Date(`${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}Z`);
}
function startOfCurrentEtHour(){
  const nowUtc = new Date();
  const etNow = toET(nowUtc); // a Date with ET wall clock but tagged Z
  etNow.setUTCMinutes(0,0,0);
  return etNow; // UTC time that corresponds to ET hour start
}
function endOfCurrentEtHour(){
  const s = startOfCurrentEtHour();
  return new Date(s.getTime() + 60*60*1000);
}

/* ============== STATE ============== */
let lastPrice = NaN;
let priceToBeat = NaN;
let stdHourly = NaN;   // σ (per 1h)
let emDollar = NaN;

/* ============== DOM HANDLES ============== */
const el = {
  price: document.getElementById('price'),
  ts: document.getElementById('ts'),
  k: document.getElementById('k'),
  timeleft: document.getElementById('timeleft'),
  gap: document.getElementById('gap'),
  em: document.getElementById('em'),
  emleft: document.getElementById('emleft'),
  strength: document.getElementById('strength'),
  up: document.getElementById('up'),
  down: document.getElementById('down'),
  footer: document.getElementById('footer'),
  sym: document.getElementById('sym'),
};

/* ============== CORE CALCS ============== */
function calcBlackScholesUpProb(S, K, sigma_hourly){
  // T = 1 hour, r ~ 0 on hourly basis
  const T = 1.0; // 1 hour unit
  const s = Math.max(sigma_hourly, 1e-9);
  const d2 = (Math.log(S/K) - 0.5*s*s*T) / (s*Math.sqrt(T));
  return normalCDF(d2); // risk-neutral probability S_T > K
}

function refreshNumbers(){
  if (!isFinite(lastPrice) || !isFinite(priceToBeat) || !isFinite(stdHourly)) return;

  const gap = lastPrice - priceToBeat;
  const em$ = lastPrice * stdHourly; // 1h expected one-sigma move in dollars
  const strength = em$>0 ? (em$/Math.abs(gap))*100 : NaN;
  const upProb = calcBlackScholesUpProb(lastPrice, priceToBeat, stdHourly);
  const downProb = 1 - upProb;

  emDollar = em$;

  el.k.textContent = fmt(priceToBeat, 2);
  el.gap.textContent = signFmt(gap, 2);
  el.em.textContent = fmt(em$, 2);
  el.emleft.textContent = fmt(Math.max(em$ - Math.abs(gap), 0), 2);
  el.strength.textContent = isFinite(strength)? fmt(strength, 1)+'%':'—';
  el.up.textContent = fmt(upProb*100, 1)+'%';
  el.down.textContent = fmt(downProb*100, 1)+'%';
}

function tickTimeLeft(){
  const now = new Date();
  const left = endOfCurrentEtHour().getTime() - now.getTime();
  const sec = Math.max(0, Math.floor(left/1000));
  const mm = String(Math.floor(sec/60)).padStart(2,'0');
  const ss = String(sec%60).padStart(2,'0');
  el.timeleft.textContent = `${mm}:${ss}`;
  el.footer.textContent = `Last update: ${new Date().toISOString().replace('T',' ').slice(0,19)} UTC · WebSocket: Binance · TZ: America/New_York (ET)`;
  if (sec===0) { // roll window
    initPriceToBeat(); // refresh K at new hour
  }
}

/* ============== DATA FETCHING ============== */
// 1) Current price via WebSocket
function startPriceStream(){
  const ws = new WebSocket(`wss://stream.binance.com:9443/ws/${SYMBOL}@trade`);
  ws.onmessage = (e)=>{
    const data = JSON.parse(e.data);
    lastPrice = parseFloat(data.p);
    el.price.textContent = fmt(lastPrice, 2);
    el.ts.textContent = `Stream ts: ${new Date(data.T).toISOString().slice(11,19)} UTC`;
    refreshNumbers();
  };
  ws.onclose = ()=>setTimeout(startPriceStream, 2000);
}

// 2) Price-to-beat = price at start of current ET hour (use closest 1m kline open)
async function initPriceToBeat(){
  try{
    const startEt = startOfCurrentEtHour().getTime();
    // Pull 120 minutes of 1m klines and find the candle whose openTime == startEt
    const end = startEt + 120*60*1000;
    const url = `https://api.binance.com/api/v3/klines?symbol=${REST_SYMBOL}&interval=1m&startTime=${startEt-5*60*1000}&endTime=${end}&limit=500`;
    const res = await fetch(url);
    const arr = await res.json();
    // Each item: [openTime, open, high, low, close, volume, closeTime, ...]
    const row = arr.find(r => r[0] === startEt) || arr[0];
    priceToBeat = parseFloat(row[1]); // open price at ET hour start
    el.k.textContent = fmt(priceToBeat, 2);
    refreshNumbers();
  }catch(e){
    console.error('K fetch fail', e);
  }
}

// 3) Realized hourly volatility from recent 1h klines
async function initHourlyVol(){
  try{
    const lim = Math.min(HOURS_FOR_RVOL, 1000);
    const url = `https://api.binance.com/api/v3/klines?symbol=${REST_SYMBOL}&interval=1h&limit=${lim}`;
    const res = await fetch(url);
    const kl = await res.json();
    const closes = kl.map(r => parseFloat(r[4]));
    const rets = [];
    for (let i=1;i<closes.length;i++){
      rets.push(Math.log(closes[i]/closes[i-1])); // hourly log-returns
    }
    // sample stdev
    const mean = rets.reduce((a,b)=>a+b,0)/rets.length;
    const var_ = rets.reduce((a,b)=>a+(b-mean)*(b-mean),0)/(rets.length-1);
    stdHourly = Math.sqrt(var_);
    refreshNumbers();
  }catch(e){
    console.error('Vol fetch fail', e);
  }
}

/* ============== BOOT ============== */
(async function boot(){
  el.sym.textContent = REST_SYMBOL;
  await initPriceToBeat();
  await initHourlyVol();
  startPriceStream();
  tickTimeLeft();
  setInterval(tickTimeLeft, 1000);

  // Refresh inputs periodically
  setInterval(initHourlyVol, 60*1000*5);   // vol every 5 min
  setInterval(initPriceToBeat, 60*1000*1); // K sanity every 1 min
})();
</script>
</body>
</html>
