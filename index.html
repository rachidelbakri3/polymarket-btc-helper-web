<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>BTC Up/Down â€” Black-Scholes Expected Move</title>
<style>
  :root{--bg:#0f172a;--card:#111827;--panel:#0b1020;--text:#e5e7eb;--muted:#9ca3af;--btn:#2563eb;}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Arial}
  .wrap{max-width:640px;margin:0 auto;padding:24px}
  h1{margin:0 0 16px;text-align:center}
  .card{background:var(--card);border-radius:14px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .kpi{display:grid;grid-template-columns:1fr auto;gap:6px;background:var(--panel);border-radius:12px;padding:12px;margin-top:10px}
  .kpi b{font-size:16px}
  label{display:block;margin:14px 0 6px;color:var(--muted);font-size:13px}
  input,button{width:100%;padding:12px;border-radius:12px;border:1px solid #374151;background:var(--panel);color:var(--text)}
  button{border:0;background:var(--btn);font-weight:700;cursor:pointer;margin-top:10px}
  .foot{margin-top:10px;text-align:center;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>BTC Up/Down (Black-Scholes)</h1>
  <div class="card">

    <div class="grid">
      <div class="kpi"><span>BTC (USDT)</span><b id="btc">â€”</b></div>
      <div class="kpi"><span>Minutes Left (UTC)</span><b id="mins">â€”</b></div>
    </div>

    <div class="kpi"><span>Price to Beat (1h open, UTC)</span><b id="ptb">â€”</b></div>

    <div class="grid">
      <div class="kpi"><span>Volatility $/min (last N mins)</span><b id="volDol">â€”</b></div>
      <div class="kpi"><span>Ïƒ annualized (Black-Scholes)</span><b id="sigmaAnn">â€”</b></div>
    </div>

    <div class="kpi"><span>Expected Move (Black-Scholes)</span><b id="em">â€”</b></div>

    <label>Current Up Price (Polymarket) â€” Ø§Ø®ØªÙŠØ§Ø±ÙŠ</label>
    <input id="upPrice" type="number" step="0.01" placeholder="e.g. 0.62 (62Â¢)">
    <button id="calc">Recalculate</button>

    <div class="grid">
      <div class="kpi"><span>Up %</span><b id="upPct">â€”</b></div>
      <div class="kpi"><span>Down %</span><b id="downPct">â€”</b></div>
    </div>
    <div class="kpi"><span>Signal</span><b id="signal">â€”</b></div>

    <div class="foot" id="stamp">Initializingâ€¦</div>
    <div class="foot">Live: Binance WebSocket Â· 1m/1h data: Binance REST Â· Time basis: UTC</div>
  </div>
</div>

<script>
/* ========= Config ========= */
const MINUTES_PER_YEAR = 525600;      // 365*24*60
const VOL_WINDOW_MINS  = 60;          // Ù†Ø§ÙØ°Ø© Ø­Ø³Ø§Ø¨ $/min (ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ±Ù‡Ø§)
const MIN_EM_PCT_FLOOR = 0.05;        // Ø£Ø¯Ù†Ù‰ Ø­Ø±ÙƒØ© Ù…ØªÙˆÙ‚Ø¹Ø© ÙƒÙ†Ø³Ø¨Ø© % Ù„Ù…Ù†Ø¹ Ø§Ù„ØµÙØ±

/* ========= State ========= */
let lastPrice = null;                 // S
let ptb = null;                       // Price to Beat (1h open)
let minutesLeft = 0;                  // Ù„Ù„Ø³Ø§Ø¹Ø© Ø§Ù„Ø¬Ø§Ø±ÙŠØ© (UTC)
let sigmaDollarPerMin = null;         // Ø§Ù†Ø­Ø±Ø§Ù Ù…Ø¹ÙŠØ§Ø±ÙŠ Ø¨Ø¯ÙˆÙ„Ø§Ø±/Ø¯Ù‚ÙŠÙ‚Ø©
let sigmaAnnual = null;               // Black-Scholes annualized Ïƒ (ÙƒÙ†Ø³Ø¨Ø©)
let expectedMoveUSD = null;           // S * Ïƒ * sqrt(T)
let secTape = [];                     // {tSec, p} Ù„ØªÙ†Ø¹ÙŠÙ… Ø§Ù„Ø³Ø¹Ø± Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ
let currentHourStart = null;

/* ========= Helpers ========= */
const fmt = (n,d=2)=>Number.isFinite(n)?n.toFixed(d):"â€”";
function hourWindowUTC(date=new Date()){
  const start = new Date(Date.UTC(date.getUTCFullYear(),date.getUTCMonth(),date.getUTCDate(),date.getUTCHours(),0,0));
  const end   = new Date(start.getTime()+3600_000);
  return {start, end, minutesLeft: Math.max(0, Math.floor((end - date)/60000))};
}
async function fetchHourOpenUTC(startMs){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${startMs}&limit=1`;
  const r = await fetch(url,{cache:'no-store'}); const j = await r.json();
  return (Array.isArray(j)&&j.length)?parseFloat(j[0][1]):null;
}
async function fetch1mCloses(limit=VOL_WINDOW_MINS+1){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${limit}`;
  const r = await fetch(url,{cache:'no-store'}); const data = await r.json();
  if (!Array.isArray(data) || data.length<2) return null;
  return data.map(k=>+k[4]); // close
}

/* ========= Volatility $/min =========
   stddev of consecutive 1m price changes (close-to-close) over last N minutes
===================================== */
function computeDollarVolPerMin(closes){
  const diffs = [];
  for(let i=1;i<closes.length;i++) diffs.push(closes[i]-closes[i-1]);
  if (diffs.length<2) return null;
  const mean = diffs.reduce((a,b)=>a+b,0)/diffs.length;
  const varp = diffs.reduce((s,x)=>s+(x-mean)*(x-mean),0)/diffs.length; // population
  return Math.sqrt(varp); // $/min
}

/* ========= Black-Scholes Expected Move =========
   Ïƒ_annual = (Ïƒ_$perMin / S) * sqrt(minutes/year)
   T(years) = minutesLeft / minutes/year
   EM($)    = S * Ïƒ_annual * sqrt(T)
   (ÙŠØ¹Ù†ÙŠ Ø±ÙŠØ§Ø¶ÙŠÙ‹Ø§ ÙŠØ³Ø§ÙˆÙŠ Ïƒ_$perMin * sqrt(minutesLeft) Ù„ÙƒÙ† Ù†Ø­Ø³Ø¨Ù‡Ø§ Ø¨ØµÙŠØºØ© BS)
=============================================== */
function computeBS_ExpectedMove(S, sigmaDolPerMin, minsLeft){
  if(!(S>0) || !(sigmaDolPerMin>0) || !(minsLeft>=0)) return {sigmaAnn:null, em:null};
  const sigmaAnn = (sigmaDolPerMin / S) * Math.sqrt(MINUTES_PER_YEAR); // Ù†Ø³Ø¨Ø© Ø³Ù†ÙˆÙŠØ©
  const T = minsLeft / MINUTES_PER_YEAR;                                // Ø³Ù†ÙˆØ§Øª
  const em = S * sigmaAnn * Math.sqrt(T);                               // $
  return {sigmaAnn, em};
}

/* ========= Probabilities (logistic) ========= */
function computeProbsAndSignal(upMarket){
  const S = lastPrice ?? 0;
  const gap = (ptb ?? S) - S;
  // Ø£Ø±Ø¶ÙŠØ© Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© ÙƒÙ†Ø³Ø¨Ø© Ù…Ù† Ø§Ù„Ø³Ø¹Ø±
  const emPct = Math.max(MIN_EM_PCT_FLOOR, (expectedMoveUSD ?? 0)/Math.max(1,S)*100);
  const scale = Math.max(1e-9, (emPct/100)*S); // Ù…Ù‚ÙŠØ§Ø³ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±
  const k = 0.85; // Ø­Ø³Ø§Ø³ÙŠØ©
  const x = gap / (k * scale);
  const up = 1/(1+Math.exp(-x));
  const down = 1-up;
  const m = isNaN(upMarket)?0.5:+upMarket;
  const sig = up - m > 0.15 ? "ðŸŸ¢ Buy Up" : (up - m < -0.15 ? "ðŸ”´ Sell Up" : "âšª Neutral");
  return {upPct:+(up*100).toFixed(1), downPct:+(down*100).toFixed(1), sig};
}

/* ========= Rendering ========= */
function render(){
  document.getElementById('btc').textContent      = fmt(lastPrice,2);
  document.getElementById('mins').textContent     = minutesLeft;
  document.getElementById('ptb').textContent      = fmt(ptb,2);
  document.getElementById('volDol').textContent   = sigmaDollarPerMin!=null ? fmt(sigmaDollarPerMin,2) : 'â€”';
  document.getElementById('sigmaAnn').textContent = sigmaAnnual!=null ? (sigmaAnnual*100).toFixed(2)+'%' : 'â€”';
  document.getElementById('em').textContent       = expectedMoveUSD!=null ? fmt(expectedMoveUSD,2) : 'â€”';

  const upM = parseFloat(document.getElementById('upPrice').value);
  const {upPct,downPct,sig} = computeProbsAndSignal(upM);
  document.getElementById('upPct').textContent = Number.isFinite(upPct)? upPct+'%':'â€”';
  document.getElementById('downPct').textContent = Number.isFinite(downPct)? downPct+'%':'â€”';
  document.getElementById('signal').textContent = sig;

  document.getElementById('stamp').textContent =
    'Last update: ' + new Date().toISOString().replace('T',' ').slice(0,19) + ' UTC';
}

/* ========= Hour maintenance (PTB + minutesLeft) ========= */
async function refreshHourStuff(){
  const {start, minutesLeft:ml} = hourWindowUTC();
  minutesLeft = ml;
  if (currentHourStart !== start.getTime()){
    currentHourStart = start.getTime();
    ptb = await fetchHourOpenUTC(currentHourStart);
  }
}

/* ========= Refresh 1m volatility each minute ========= */
let lastVolMinute = null;
async function refreshVolIfNewMinute(){
  const nowMin = Math.floor(Date.now()/60000);
  if (nowMin !== lastVolMinute){
    lastVolMinute = nowMin;
    const closes = await fetch1mCloses(VOL_WINDOW_MINS+1);
    const volDol = closes ? computeDollarVolPerMin(closes) : null;
    sigmaDollarPerMin = volDol;

    // Ø¨Ø¹Ø¯ ØªØ­Ø¯ÙŠØ« $/minØŒ Ø§Ø­Ø³Ø¨ Ïƒ Ø§Ù„Ø³Ù†ÙˆÙŠØ© Ùˆ EM Ø¨Ù…Ø¹Ø§Ø¯Ù„Ø© Black-Scholes
    if (lastPrice!=null && sigmaDollarPerMin!=null){
      const {sigmaAnn, em} = computeBS_ExpectedMove(lastPrice, sigmaDollarPerMin, minutesLeft);
      sigmaAnnual = sigmaAnn;
      expectedMoveUSD = em;
    }
  }
}

/* ========= WebSocket live price (per second tape) ========= */
function startWS(){
  const ws = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@trade");
  ws.onmessage = (ev)=>{
    const {p,T} = JSON.parse(ev.data);
    const price = parseFloat(p);
    const tSec  = Math.floor((T||Date.now())/1000);
    lastPrice = price;
    if (secTape.length && secTape[secTape.length-1].tSec===tSec) secTape[secTape.length-1].p=price;
    else secTape.push({tSec,p:price});
    // Ø­Ø¯Ù‘Ø« EM ÙÙˆØ±Ù‹Ø§ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ïƒ_$/min Ø§Ù„Ø£Ø­Ø¯Ø«
    if (sigmaDollarPerMin!=null){
      const res = computeBS_ExpectedMove(lastPrice, sigmaDollarPerMin, minutesLeft);
      sigmaAnnual = res.sigmaAnn; expectedMoveUSD = res.em;
    }
    render();
  };
  ws.onclose = ()=> setTimeout(startWS, 1500);
}

/* ========= Boot ========= */
document.getElementById('calc').addEventListener('click', render);

(async function boot(){
  await refreshHourStuff();
  await refreshVolIfNewMinute();  // Ø­Ø³Ø§Ø¨ Ø£ÙˆÙ„ÙŠ Ù„Ù„Ù€ $/min ÙˆØ§Ù„Ù€ EM
  startWS();
  render();

  // ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©: Ø­Ø¯Ù‘Ø« Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØŒ ÙˆØ¹Ù†Ø¯ Ø¯Ø®ÙˆÙ„ Ø¯Ù‚ÙŠÙ‚Ø© Ø¬Ø¯ÙŠØ¯Ø© ÙŠØ¹Ø§Ø¯ Ø­Ø³Ø§Ø¨ $/min ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
  setInterval(async ()=>{
    await refreshHourStuff();
    await refreshVolIfNewMinute();
    render();
  }, 1000);
})();
</script>
</body>
</html>
